{% extends "layout.html" %}

{% block title %}
    Task Manager
{% endblock %}

{% block style %}
<style>
    /* Custom styles to enhance Bootstrap */
    body {
        font-family: 'Inter', sans-serif;
        background-color: #f8f9fa;
    }

    h1 {
        color: #343a40;
        font-weight: 600;
        margin-bottom: 1.5rem;
        text-align: center;
    }
    
    .drag-handle {
        cursor: grab;
        color: #adb5bd;
        margin-right: 8px;
        font-size: 1.1rem;
    }

    .drag-handle:active {
        cursor: grabbing;
    }

    .task-header {
        display: flex;
        align-items: center;
        position: relative;
        gap: 0.5rem;
        margin-bottom: 0.4rem;
        flex-wrap: wrap; 
    }

    .project-name-centered {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1; 
        width: fit-content;
        white-space: nowrap;
    }

    .task-header > .mb-2.text-end.ms-auto {
        margin-left: auto;
        position: relative;
        z-index: 2;
    }

    .task-header h2 + .mb-2 {
        margin-left: auto !important;
    }

    .task-header input[type="text"],
    .task-header input[type="date"] {
        flex-grow: 1;
        min-width: 120px;
        border-radius: 0.375rem;
    }
    
    .task-options, .subtask-list {
        display: grid;
        grid-template-rows: 1fr;
        transition: grid-template-rows 0.3s ease-in-out, margin-top 0.3s ease-in-out;
        margin-top: 0.5rem;
    }
    .task-options > *, .subtask-list > * {
        overflow: hidden;
    }

    .task-options.task-options-minimized {
        grid-template-rows: 0fr;
        margin-top: 0;
    }

    .card {
        border-radius: 0.5rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.075);
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        margin-bottom: 0.5rem;
    }

    .card-body {
        padding: 0.75rem;
    }

    .btn {
        border-radius: 0.375rem;
        font-weight: 500;
        transition: all 0.2s ease-in-out;
        padding: 0.4rem 0.75rem;
    }

    /* Styles for compact inputs and placeholders */
    .form-floating > .form-control {
        height: calc(3rem + 2px);
        padding: 1rem 0.75rem 0.25rem;
    }
    .form-floating > .form-control:not(:placeholder-shown) {
        padding-top: 1.25rem;
        padding-bottom: 0.25rem;
    }
    .form-floating > label { padding: 0.75rem 0.75rem; }
    #task-manager-form textarea.form-control { height: 80px !important; }
    .form-control::placeholder {
        color: #6c757d;
        opacity: 1;
    }

    /* Animation Styles for SortableJS */
    .sortable-ghost {
        opacity: 0.4;
        background-color: #c8ebfb;
        border: 2px dashed #0d6efd;
    }
    .sortable-chosen {
        cursor: grabbing;
        box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
        transform: scale(1.02);
    }
    
.subtask-level-0 {
  background-color: #ffffff;
  border: 1px solid #d0d0d0;
  border-left: 3px solid #5a5a5a; /* Neutral Grey */
}

.subtask-level-1 {background-color: #f9f9f9;border: 1px solid #cccccc;margin-left: 5px;   width: calc(100% - 5px);border-left: 3px solid #4a90e2; /* Blue */}
.subtask-level-2 {background-color: #f6f6f6;border: 1px solid #bbbbbb;margin-left: 10px;      width: calc(100% - 10px);border-left: 3px solid #50e3c2; /* Aqua */}
.subtask-level-3 {background-color: #f2f2f2;border: 1px solid #aaaaaa;margin-left: 15px;  width: calc(100% - 15px);border-left: 3px solid #f5a623; /* Orange */}
.subtask-level-4 {background-color: #eeeeee;border: 1px solid #999999;margin-left: 20px;      width: calc(100% - 20px);   border-left: 3px solid #d96c4f; /* Warm Coral */}
.subtask-level-5 {background-color: #ebebeb;border: 1px solid #888888;margin-left: 25px;      width: calc(100% - 25px);border-left: 3px solid #9013fe; /* Violet */}
.subtask-level-6 {background-color: #e7e7e7;border: 1px solid #777777;margin-left: 30px;      width: calc(100% - 30px);border-left: 3px solid #417505; /* Deep Green */}

    /* Styles for completed tasks */
    .completed-task {
        border-color: #c3e6cb !important;
        position: relative;
        overflow: hidden;
    }
    .card.completed-task::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(212, 237, 218, 0.7);
        z-index: 1;
        border-radius: inherit;
    }
    .card.completed-task .card-body {
        position: relative;
        z-index: 2;
    }
    .completed-task .task-header input[type="text"],
    .completed-task .task-header h4 {
        text-decoration: line-through;
        color: #6c757d;
    }

    /* Alert message styling */
    .alert-message {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1050;
        display: none;
        animation: fadeOut 4s forwards;
    }

    @keyframes fadeOut {
        0% { opacity: 1; }
        80% { opacity: 1; }
        100% { opacity: 0; display: none; }
    }
</style>
{% endblock %}

{% block username %}
    <div class="fs-6 fw-bold">Hi, {{username}}.</div>
{% endblock %}

{% block main %}
    <div class="container-fluid mt-5">
        <form id="task-manager-form" method="POST">
            <input type="hidden" id="project_id" name="project_id" value="{{ project_id }}">
            <div class="task-list">

                {% macro render_task_item(task, level=0) %}
                    <div class="card subtask-level-{{ level }} mb-1 {% if task.is_completed %}completed-task{% endif %}" 
                         data-item-id="{{ task.item_id }}" 
                         data-parent-item-id="{{ task.parent_item_id if task.parent_item_id is defined else '' }}" 
                         data-level="{{ level }}">
                        <div class="card-body">
                            <div class="task-header">
                                {% if level > 0 %}
                                    <span class="drag-handle"><i class="fa-solid fa-grip-vertical"></i></span>
                                    <div class="form-floating flex-grow-1">
                                        <input type="text" class="form-control" id="name_{{ task.item_id | replace('.', '_') }}" name="name_{{ task.item_id | replace('.', '_') }}" value="{{ task.name }}" placeholder="Subtask Name">
                                        <label for="name_{{ task.item_id | replace('.', '_') }}">Task Name</label>
                                    </div>
                                {% else %}
                                    <h2 class="mb-0 fs-15 fw-bold project-name-centered">{{ project_name }}</h2>
                                    <div class="mb-2 text-end ms-auto">
                                        <strong class="text-muted">Remaining Time:</strong>
                                        <span id="remaining-hours-display" class="fs-5 fw-bold text-warning">
                                            -- hrs
                                        </span>
                                    </div>
                                {% endif %}
                                
                                {% if level > 0 %}
                                    <button type="button" class="btn btn-sm btn-outline-primary add-subtask-btn"><i class="fa-solid fa-plus"></i></button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary toggle-subtasks-btn"><span class="collapse-icon">{% if task.is_minimized %}&#9650;{% else %}&#9660;{% endif %}</span></button>
                                    <button type="button" class="btn btn-sm btn-outline-danger delete-task-btn"><i class="fa-solid fa-trash"></i></button>
                                {% endif %}
                            </div>

                            {% if level > 0 %}
                                <div class="task-options {% if task.is_minimized %}task-options-minimized{% endif %}">
                                    <div class="d-flex flex-wrap align-items-center gap-2">
                                        <div class="d-flex align-items-center gap-1" style="max-width: 200px;">
                                            <label for="planned_hours_{{ task.item_id | replace('.', '_') }}" class="form-label small mb-0 text-nowrap">Planned Hrs:</label>
                                            <input type="number" min="0" step="0.1" class="form-control form-control-sm flex-grow-1"
                                                   id="planned_hours_{{ task.item_id | replace('.', '_') }}"
                                                   name="planned_hours_{{ task.item_id | replace('.', '_') }}"
                                                   value="{{ task.planned_hours if task.planned_hours is not none else '' }}"
                                                   placeholder="0.0">
                                        </div>

                                        {% if task.due_date is defined %}
                                        <div class="d-flex align-items-center gap-1" style="max-width: 200px;">
                                            <label for="due_date_{{ task.item_id | replace('.', '_') }}" class="form-label small mb-0 text-nowrap">Due Date:</label>
                                            <input type="date" class="form-control form-control-sm flex-grow-1" id="due_date_{{ task.item_id | replace('.', '_') }}" name="due_date_{{ task.item_id | replace('.', '_') }}" value="{{ task.due_date }}">
                                        </div>
                                        {% endif %}
                                        
                                        {% if task.subtasks %}
                                        <div class="text-end ms-auto">
                                            <strong class="text-muted">Subtask Sum:</strong>
                                            <span class="fs-6 fw-bold text-info">
                                                {{ "%.1f" | format(task.calculated_planned_hours) if task.calculated_planned_hours is not none else "N/A" }} hrs
                                            </span>
                                        </div>
                                        {% endif %}

                                        <div class="form-floating flex-grow-1 w-100">
                                            <textarea class="form-control" placeholder="Description" id="description_{{ task.item_id | replace('.', '_') }}" name="description_{{ task.item_id | replace('.', '_') }}">{{ task.description }}</textarea>
                                            <label for="description_{{ task.item_id | replace('.', '_') }}">Description</label>
                                        </div>

                                        <div class="form-check mb-2">
                                            <input type="checkbox" class="form-check-input completed-checkbox" id="is_completed_{{ task.item_id | replace('.', '_') }}" name="is_completed_{{ task.item_id | replace('.', '_') }}" {% if task.is_completed %}checked{% endif %}>
                                            <label class="form-check-label" for="is_completed_{{ task.item_id | replace('.', '_') }}">Completed</label>
                                        </div>
                                    </div>
                                </div>
                            {% else %}
                                <div class="task-options mb-1 mx-auto fs-6 fw-bold i">
                                    "{{ project_details.description }}"
                                </div>
                            {% endif %}
                            
                            {% if task.subtasks %}
                            <div class="subtask-list">
                                {% for subtask in task.subtasks %}
                                    {{ render_task_item(subtask, level + 1) }}
                                {% endfor %}
                            </div>
                            {% endif %}

                            {% if level == 0 %}
                                <div class="d-flex justify-content-center mt-3">
                                    <button type="button" class="btn btn-primary add-subtask-btn px-4">
                                        <i class="fa-solid fa-plus me-2"></i> Add Subtask
                                    </button>
                                </div>
                            {% endif %}
                        </div>
                    </div>
                {% endmacro %}
    
                {% for task in tasks %}
                    {{ render_task_item(task, 0) }}
                {% endfor %}
            </div>
            <button type="submit" class="btn btn-success mt-3">
                <i class="fa-regular fa-floppy-disk"></i>
                Save
            </button>
        </form>
    </div>

    <div id="alertMessage" class="alert-message"></div>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        let newItemIdCounter = 0;
        const deletedItemIds = new Set();
        const MAX_SUBTASK_LEVEL = 6;

        attachEventListeners(document);

        document.querySelectorAll('.completed-checkbox').forEach(checkbox => {
            const taskCard = checkbox.closest('.card');
            if (taskCard && checkbox.checked) {
                applyCompletionStyles(taskCard, true);
            }
        });

        document.querySelectorAll('.task-list, .subtask-list').forEach(initSortable);
        
        const taskManagerForm = document.getElementById('task-manager-form');
        taskManagerForm.addEventListener('submit', handleFormSubmit);
        
        updateRemainingHours();

        function initSortable(listEl) {
            new Sortable(listEl, {
                group: 'nested-tasks',
                animation: 150,
                handle: '.drag-handle',
                fallbackOnBody: true,
                swapThreshold: 0.65,
                onAdd: function (evt) {
                    const item = evt.item;
                    const newParentCard = item.closest('.card:not([data-item-id="' + item.dataset.itemId + '"])');
                    const newParentId = newParentCard ? newParentCard.dataset.itemId : '';
                    item.dataset.parentItemId = newParentId;
                }
            });
        }

        function collectTaskData(container) {
            const items = [];
            container.querySelectorAll(':scope > .card').forEach((card, index) => {
                const itemId = card.dataset.itemId;
                const parentItemId = card.dataset.parentItemId || null;
                const level = parseInt(card.dataset.level, 10);

                if (level > 0) {
                    const name = card.querySelector(`input[id^="name_"]`).value;
                    const description = card.querySelector(`textarea[id^="description_"]`).value;
                    const dueDate = card.querySelector(`input[id^="due_date_"]`).value;
                    const isCompleted = card.querySelector(`input[id^="is_completed_"]`).checked;
                    const plannedHours = card.querySelector(`input[id^="planned_hours_"]`).value;
                    const isMinimized = card.querySelector('.task-options').classList.contains('task-options-minimized');
                    
                    let subtasks = [];
                    const subtaskListContainer = card.querySelector('.subtask-list');
                    if (subtaskListContainer) {
                       subtasks = collectTaskData(subtaskListContainer);
                    }

                    const itemObject = {
                        item_id: itemId,
                        parent_item_id: parentItemId,
                        name: name,
                        description: description,
                        due_date: dueDate || null,
                        is_completed: isCompleted,
                        is_minimized: isMinimized,
                        planned_hours: plannedHours || null,
                        display_order: index,
                        subtasks: subtasks
                    };
                    items.push(itemObject);
                }
            });
            if (container.classList.contains('task-list')) {
                const rootCard = container.querySelector(':scope > .card');
                if (rootCard) {
                    const subtaskList = rootCard.querySelector('.subtask-list');
                    if (subtaskList) {
                        return collectTaskData(subtaskList);
                    }
                }
                return [];
            }
            return items;
        }

        async function handleFormSubmit(event) {
            event.preventDefault(); // Always prevent the default submission first

            let isDataValid = true;
            // Find all date inputs in the form to validate them
            document.querySelectorAll('.card[data-level]:not([data-level="0"]) input[type="date"]').forEach(dateInput => {
                const subtaskCard = dateInput.closest('.card');
                const parentCard = subtaskCard.closest('.subtask-list')?.closest('.card');
                const parentDueDateInput = parentCard?.querySelector('input[type="date"]');

                // Check for the invalid condition: parent has a due date AND the subtask's due date is later.
                if (parentDueDateInput && parentDueDateInput.value && dateInput.value) {
                    if (dateInput.value > parentDueDateInput.value) {
                        const taskName = subtaskCard.querySelector('input[id^="name_"]').value || "Untitled Task";
                        showAlert(`Validation Error: Task "${taskName}" cannot be due after its parent.`);
                        isDataValid = false; // Mark data as invalid
                    }
                }
            });

            // If the validation loop found any errors, STOP the submission.
            if (!isDataValid) {
                return;
            }

            // --- Original save logic will only run if the data is valid ---
            const projectId = document.getElementById('project_id').value;
            const tasksData = collectTaskData(document.querySelector('.task-list'));
            const payload = {
                project_id: projectId,
                tasks: tasksData,
                deleted_item_ids: Array.from(deletedItemIds)
            };

            try {
                const response = await fetch('/save-tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (response.ok) {
                    window.location.reload();
                } else {
                    showAlert(`Failed to save tasks: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                showAlert('Error saving tasks. Please check your connection.');
            }
        }
        
        function attachEventListeners(container) {
            container.addEventListener('click', function(event) {
                const addBtn = event.target.closest('.add-subtask-btn');
                const deleteBtn = event.target.closest('.delete-task-btn');
                const toggleBtn = event.target.closest('.toggle-subtasks-btn');
                if (addBtn) handleAddSubtask(addBtn);
                if (deleteBtn) handleDeleteTask(deleteBtn);
                if (toggleBtn) handleMinimizeToggle(toggleBtn);
            });

            container.addEventListener('change', function(event) {
                const checkbox = event.target.closest('.completed-checkbox');
                if (checkbox) handleCompletionChange(checkbox);

                // Correctly target the due date input
                if (event.target.matches('input[type="date"]')) {
                    validateDueDate(event.target);
                }
            });

            container.addEventListener('input', function(event) {
                if (event.target.matches('input[id^="planned_hours_"]')) {
                    updateRemainingHours();
                }
            });
        }

        function handleAddSubtask(button) {
            const parentCard = button.closest('.card');
            if (!parentCard) return;
            const parentLevel = parseInt(parentCard.dataset.level, 10);
            const newLevel = parentLevel + 1;
            if (newLevel > MAX_SUBTASK_LEVEL) {
                showAlert(`You can only create up to ${MAX_SUBTASK_LEVEL} levels of subtasks.`);
                return;
            }
            const parentId = parentCard.dataset.itemId;
            const newId = `new-${++newItemIdCounter}`;
            const newSubtaskHtml = generateTaskHtml(newId, parentId, newLevel);
            
            let subtaskList = parentCard.querySelector('.subtask-list');
            if (!subtaskList) {
                const newSubtaskListDiv = document.createElement('div');
                newSubtaskListDiv.className = 'subtask-list';
                parentCard.querySelector('.card-body').appendChild(newSubtaskListDiv);
                subtaskList = newSubtaskListDiv;
                initSortable(subtaskList);
            }

            subtaskList.insertAdjacentHTML('beforeend', newSubtaskHtml);
            
            if(subtaskList.classList.contains('subtask-list-collapsed')) {
                const toggleBtn = parentCard.querySelector('.toggle-subtasks-btn');
                if (toggleBtn) handleMinimizeToggle(toggleBtn);
            }
            updateRemainingHours();
        }

        function handleDeleteTask(button) {
            const cardToDelete = button.closest('.card');
            if (cardToDelete) {
                const itemId = cardToDelete.dataset.itemId;
                if (!itemId.startsWith('new-')) {
                    deletedItemIds.add(itemId);
                }
                cardToDelete.remove();
                updateRemainingHours();
            }
        }

        function handleCompletionChange(checkbox) {
            const taskCard = checkbox.closest('.card');
            if (!taskCard) return;
            const isCompleted = checkbox.checked;
            applyCompletionStyles(taskCard, isCompleted);
            if (isCompleted) {
                propagateCompletionDownwards(taskCard.querySelector('.subtask-list'), true);
            } else {
                propagateUncompletionUpwards(taskCard);
            }
            updateRemainingHours();
        }
        
        /**
         * MODIFICATION: This function now correctly cascades minimization to ALL descendant subtasks.
         * The selector was updated to find all nested cards, not just immediate children.
         */
        function handleMinimizeToggle(button) {
            const taskCard = button.closest('.card');
            const taskOptions = taskCard.querySelector(':scope > .card-body > .task-options');
            const collapseIcon = button.querySelector('.collapse-icon');

            // Toggle the main task's options visibility
            taskOptions.classList.toggle('task-options-minimized');
            const isMinimized = taskOptions.classList.contains('task-options-minimized');

            // Update the icon for the main task
            collapseIcon.innerHTML = isMinimized ? '&#9650;' : '&#9660;';

            // When the parent is minimized, cascade the minimization to all descendants.
            if (isMinimized) {
                // This selector finds ALL nested .card elements, ensuring the effect cascades.
                const allDescendantSubtasks = taskCard.querySelectorAll('.subtask-list .card');

                allDescendantSubtasks.forEach(subtaskCard => {
                    const subtaskOptions = subtaskCard.querySelector(':scope > .card-body > .task-options');
                    const subtaskCollapseIcon = subtaskCard.querySelector('.toggle-subtasks-btn .collapse-icon');

                    if (subtaskOptions) {
                        subtaskOptions.classList.add('task-options-minimized');
                    }
                    if (subtaskCollapseIcon) {
                        subtaskCollapseIcon.innerHTML = '&#9650;';
                    }
                });
            }
        }

        function generateTaskHtml(itemId, parentItemId, level) {
            const htmlId = itemId.replace(/[.-]/g, '_');
            const addBtn = level < MAX_SUBTASK_LEVEL ? `<button type="button" class="btn btn-sm btn-outline-primary add-subtask-btn"><i class="fa-solid fa-plus"></i></button>` : '';
            return `
            <div class="card subtask-level-${level} mb-1" data-item-id="${itemId}" data-parent-item-id="${parentItemId}" data-level="${level}">
                <div class="card-body">
                    <div class="task-header">
                        <span class="drag-handle"><i class="fa-solid fa-grip-vertical"></i></span>
                        <div class="form-floating flex-grow-1">
                            <input type="text" class="form-control" id="name_${htmlId}" name="name_${htmlId}" placeholder="Subtask Name">
                            <label for="name_${htmlId}">Subtask Name</label>
                        </div>
                        ${addBtn}
                        <button type="button" class="btn btn-sm btn-outline-secondary toggle-subtasks-btn"><span class="collapse-icon">&#9660;</span></button>
                        <button type="button" class="btn btn-sm btn-outline-danger delete-task-btn"><i class="fa-solid fa-trash"></i></button>
                    </div>
                    <div class="task-options">
                        <div class="d-flex flex-wrap align-items-center gap-2">
                            <div class="d-flex align-items-center gap-1" style="max-width: 200px;">
                                <label for="planned_hours_${htmlId}" class="form-label small mb-0 text-nowrap">Planned Hrs:</label>
                                <input type="number" min="0" step="0.1" class="form-control form-control-sm flex-grow-1" id="planned_hours_${htmlId}" name="planned_hours_${htmlId}" placeholder="0.0">
                            </div>
                            <div class="d-flex align-items-center gap-1" style="max-width: 200px;">
                                <label for="due_date_${htmlId}" class="form-label small mb-0 text-nowrap">Due Date:</label>
                                <input type="date" class="form-control form-control-sm flex-grow-1" id="due_date_${htmlId}" name="due_date_${htmlId}">
                            </div>
                            <div class="form-floating flex-grow-1 w-100">
                                <textarea class="form-control" placeholder="Description" id="description_${htmlId}" name="description_${htmlId}"></textarea>
                                <label for="description_${htmlId}">Description</label>
                            </div>
                            <div class="form-check mb-2">
                                <input type="checkbox" class="form-check-input completed-checkbox" id="is_completed_${htmlId}" name="is_completed_${htmlId}">
                                <label class="form-check-label" for="is_completed_${htmlId}">Completed</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;
        }

        function updateRemainingHours() {
            const displayElement = document.getElementById('remaining-hours-display');
            if (!displayElement) return;
            let totalHours = 0;
            let completedHours = 0;
            const hourInputs = document.querySelectorAll('.card[data-level]:not([data-level="0"]) input[id^="planned_hours_"]');
            hourInputs.forEach(input => {
                const value = parseFloat(input.value);
                if (!isNaN(value)) {
                    totalHours += value;
                    const taskCard = input.closest('.card');
                    if (taskCard && taskCard.classList.contains('completed-task')) {
                        completedHours += value;
                    }
                }
            });
            const remainingHours = totalHours - completedHours;
            displayElement.textContent = `${remainingHours.toFixed(1)}hrs`;
            if (remainingHours <= 0 && totalHours > 0) {
                displayElement.classList.remove('text-warning');
                displayElement.classList.add('text-success');
            } else {
                displayElement.classList.remove('text-success');
                displayElement.classList.add('text-warning');
            }
        }

        function showAlert(message) {
            const alertBox = document.getElementById('alertMessage');
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            alertBox.style.animation = 'none';
            void alertBox.offsetWidth;
            alertBox.style.animation = 'fadeOut 4s forwards';
        }

        function applyCompletionStyles(taskCard, isCompleted) {
            if (isCompleted) {
                taskCard.classList.add('completed-task');
            } else {
                taskCard.classList.remove('completed-task');
            }
        }

        function propagateCompletionDownwards(subtaskListContainer, isCompleted) {
            if (!subtaskListContainer) return;
            subtaskListContainer.querySelectorAll(':scope > .card').forEach(subtaskCard => {
                const checkbox = subtaskCard.querySelector('.completed-checkbox');
                if (checkbox && checkbox.checked !== isCompleted) {
                    checkbox.checked = isCompleted;
                    applyCompletionStyles(subtaskCard, isCompleted);
                }
                const nestedSubtaskList = subtaskCard.querySelector('.subtask-list');
                if (nestedSubtaskList) {
                   propagateCompletionDownwards(nestedSubtaskList, isCompleted);
                }
            });
        }

        function propagateUncompletionUpwards(currentTaskCard) {
            let parentCard = currentTaskCard.closest('.subtask-list')?.closest('.card');
            if (parentCard) {
                const parentCheckbox = parentCard.querySelector('.completed-checkbox');
                if (parentCheckbox && parentCheckbox.checked) {
                    parentCheckbox.checked = false;
                    applyCompletionStyles(parentCard, false);
                    propagateUncompletionUpwards(parentCard);
                }
            }
        }

/**
         * Validates that a subtask's due date is not earlier than its parent's.
         * This version uses direct string comparison to avoid timezone issues.
         * @param {HTMLInputElement} dateInput The date input element that was changed.
         */
        function validateDueDate(dateInput) {
            const subtaskCard = dateInput.closest('.card');
            if (!subtaskCard) return;

            // Find the parent card by navigating up the DOM tree
            const parentCard = subtaskCard.closest('.subtask-list')?.closest('.card');
            if (!parentCard) {
                // This subtask has no parent in the current structure, so no validation needed
                return;
            }

            // Find the parent's due date input
            const parentDueDateInput = parentCard.querySelector('input[type="date"]');
            if (!parentDueDateInput || !parentDueDateInput.value) {
                // Parent has no due date set, so we can't validate against it
                return;
            }
            
            const parentDueDateStr = parentDueDateInput.value;
            const subtaskDueDateStr = dateInput.value;

            // Only compare if the subtask has a date
            if (subtaskDueDateStr && subtaskDueDateStr > parentDueDateStr) {
                showAlert("A subtask's due date cannot be later than its parent's due date.");
                dateInput.value = ''; // Reset the invalid date
            }
        }
    });
</script>
{% endblock %}